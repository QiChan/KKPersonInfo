1.page
InnoDB采取的方式是：将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小一般为 16 KB。也就是在一般情况下，一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。

2. InnoDB 行格式
我们平时是以记录为单位来向表中插入数据的，这些记录在磁盘上的存放方式也被称为行格式或者记录格式。设计InnoDB存储引擎的大叔们到现在为止设计了4种不同类型的行格式，分别是Compact、Redundant、Dynamic和Compressed行格式，随着时间的推移，他们可能会设计出更多的行格式，但是不管怎么变，在原理上大体都是相同的。

3. 指定行格式的语法
CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称
ALTER TABLE 表名 ROW_FORMAT=行格式名称

example:
mysql> USE xiaohaizi;
Database changed

mysql> CREATE TABLE record_format_demo (
    ->     c1 VARCHAR(10),
    ->     c2 VARCHAR(10) NOT NULL,
    ->     c3 CHAR(10),
    ->     c4 VARCHAR(10)
    -> ) CHARSET=ascii ROW_FORMAT=COMPACT;

插入两条记录：
mysql> INSERT INTO record_format_demo(c1, c2, c3, c4) VALUES('aaaa', 'bbb', 'cc', 'd'), ('eeee', 'fff', NULL, NULL);
Query OK, 2 roQuery OK, 0 rows affected (0.03 sec)
ws affected (0.02 sec)
Records: 2  Duplicates: 0  Warnings: 0

现在表中记录的样子
pmysql> SELECT * FROM record_format_demo;
+------+-----+------+------+
| c1   | c2  | c3   | c4   |
+------+-----+------+------+
| aaaa | bbb | cc   | d    |
| eeee | fff | NULL | NULL |
+------+-----+------+------+
2 rows in set (0.00 sec)

mysql>

其中'aaaa'是字一行中的所有字段（可能包含某些隐藏字段）是一条记录

4. compact行格式的额外信息
这部分信息是服务器为了描述这条记录而不得不额外添加的一些信息，这些额外信息分为3类，分别是变长字段长度列表、NULL值列表和记录头信息

5. SHOW CHARSET
假设某个字符集中表示一个字符最多需要使用的字节数为W，也就是使用SHOW CHARSET语句的结果中的Maxlen列，比方说utf8字符集中的W就是3，gbk字符集中的W就是2，ascii字符集中的W就是1。

6. 变长字段长度列表
如果该可变字段允许存储的最大字节数（M×W）不超过255字节，那么使用1个字节来表示真正字符串占用的字节数
如果该可变字段允许存储的最大字节数（M×W）超过255字节并且真实存储的字节数（L）超过127字节，则使用2个字节，否则使用1个字节来表示真正字符串占用的字节数。

7. 判断某个字节是否代表完整字段
InnoDB在读记录的变长字段长度列表时先查看表结构，如果某个变长字段允许存储的最大字节数大于255时，该怎么区分它正在读的某个字节是一个单独的字段长度还是半个字段长度呢？设计InnoDB的大叔使用该字节的第一个二进制位作为标志位：如果该字节的第一个位为0，那该字节就是一个单独的字段长度（使用一个字节表示不大于127的二进制的第一个位都为0），如果该字节的第一个位为1，那该字节就是半个字段长度。

8. 主键
主键就是被挑选出来，作为表的行的唯一标识的候选关键字。主键可以由一个字段，也可以由多个字段组成，分别称为单字段主键或多字段主键。

9. the hex
in ascii, the char 'a' in hex is 61, so the string 'aaaa' in ascii of hex is 0x61616161

10. CHAR(M)的长度也可能存储到变长字段长度列表中
在Compact行格式下, 且采用的字符集是定长字符集，则只会把变长类型的列的长度逆序存到变长字段长度列表中。
若采用的是变长的字符集，则CHAR(M)列的长度也会被存储到变长字段长度列表中

对于 CHAR(M) 类型的列来说，当列采用的是定长字符集时，该列占用的字节数不会被加到变长字段长度列表，而如果采用变长字符集时，该列占用的字节数也会被加到变长字段长度列表。

11. 碎片
小片的空白空间？

12. Redundant行格式
如果存储NULL值的字段是定长类型的，比方说CHAR(M)数据类型的，则NULL值也将占用记录的真实数据部分，并把该字段对应的数据使用0x00字节填充。
如果该存储NULL值的字段是变长数据类型的，则不在记录的真实数据处占用任何存储空间。

13. 常识
VARCHAR(M)类型的列最多可以占用65535个字节

example:
mysql> CREATE TABLE varchar_size_demo(
    ->     c VARCHAR(65535)
    -> ) CHARSET=ascii ROW_FORMAT=Compact;

一定要记住一个行中的所有列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过65535个字节！

14. 行溢出
example:
mysql> INSERT INTO varchar_size_demo(c) VALUES(REPEAT('a', 65532));
Query OK, 1 row affected (0.00 sec)

MySQL中磁盘和内存交互的基本单位是页，也就是说MySQL是以页为基本单位来管理存储空间的，我们的记录都会被分配到某个页中存储。而一个页的大小一般是16KB，也就是16384字节

不只是 VARCHAR(M) 类型的列，其他的 TEXT、BLOB 类型的列在存储数据非常多的时候也会发生行溢出。

15.一个页中最少的记录存放量
MySQL中规定一个页中至少存放两行记录

16. 指定和修改行格式的语法如下：

CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称
(列的信息？)

ALTER TABLE 表名 ROW_FORMAT=行格式名称

17.
example:
mysql> CREATE TABLE page_demo(
    ->     c1 INT,
    ->     c2 INT,
    ->     c3 VARCHAR(10000),
    ->     PRIMARY KEY (c1)
    -> ) CHARSET=ascii ROW_FORMAT=Compact;
Query OK, 0 rows affected (0.03 sec)


mysql> INSERT INTO page_demo VALUES(1, 100, 'aaaa'), (2, 200, 'bbbb'), (3, 300, 'cccc'), (4, 400, 'dddd');
Query OK, 4 rows affected (0.00 sec)
Records: 4  Duplicates: 0  Warnings: 0

18. 比较记录的大小
对于`一条完整的记录`来说，比较记录的大小就相当于比的是主键的大小

19.记录的链表和记录的辣鸡链表
example:
mysql> DELETE FROM page_demo WHERE c1 = 2;
Query OK, 1 row affected (0.02 sec)

不论我们怎么对页中的记录做增删改操作，InnoDB始终会维护一条记录的单链表，链表中的各个节点是按照主键值由小到大的接起来的.
当数据页中存在多条被删除掉的记录时，这些记录的next_record属性将会把这些被删除掉的记录组成一个垃圾链表，以备之后重用这部分存储空间。

20. 页正常记录分成几组的规定
对于最小记录所在的分组只能有 1 条记录，最大记录所在的分组拥有的记录条数只能在 1~8 条之间，剩下的分组中记录的条数范围只能在是 4~8 条之间

21. maybe hard to comprehend
之后每插入一条记录，都会从页目录中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对应的记录的n_owned值加1，表示本组内又添加了一条记录，直到该组中的记录数等于8个。

22.在一个数据页中查找指定主键值的记录的过程分为两步：
通过二分法确定该记录所在的槽，并找到该槽中主键值最小的那条记录。
通过记录的next_record属性遍历该槽所在的组中的各个记录。

23. maybe hard to comprehend
PAGE_N_DIRECTION
假设连续几次插入新记录的方向都是一致的，InnoDB会把沿着同一个方向插入记录的条数记下来，这个条数就用PAGE_N_DIRECTION这个状态表示。当然，如果最后一条记录的插入方向改变了的话，这个状态的值会被清零重新统计。

24. 新分配的数据页
新分配的数据页编号可能并不是连续的，也就是说我们使用的这些页在存储空间里可能并不挨着。
下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。这个过程我们也可以称为页分裂。

25. B+树特性(聚簇索引)
B+树本身就是一个目录，或者说本身就是一个索引。它有两个特点：

1.使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：

页内的记录是按照主键的大小顺序排成一个单向链表。

各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表。

存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表。

2.B+树的叶子节点存储的是完整的用户记录。

所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。

26. 显式指定需要创建索引的列
我们可以在创建表的时候指定需要建立索引的单个列或者建立联合索引的多个列：

CREATE TALBE 表名 (
    各种列的信息 ··· ,
    [KEY|INDEX] 索引名 (需要被索引的单个列或多个列)
)

example:
比方说我们想在创建index_demo表的时候就为c2和c3列添加一个联合索引，可以这么写建表语句：

CREATE TABLE index_demo(
    c1 INT,
    c2 INT,
    c3 CHAR(1),
    PRIMARY KEY(c1),
    INDEX idx_c2_c3 (c2, c3)
);

在这个建表语句中我们创建的索引名是idx_c2_c3，这个名称可以随便起，不过我们还是建议以idx_为前缀，后边跟着需要建立索引的列名，多个列名之间用下划线_分隔开。

27. 修改表结构的时候添加索引
ALTER TABLE 表名 ADD [INDEX|KEY] 索引名 (需要被索引的单个列或多个列);

28. 修改表结构的时候删除索引
ALTER TABLE 表名 DROP [INDEX|KEY] 索引名;

example:
ALTER TABLE index_demo DROP INDEX idx_c2_c3;

29. InnoDB存储引擎的B+树索引，我们必须熟悉下边这些结论
1.每个索引都对应一棵B+树，B+树分为好多层，最下边一层是叶子节点，其余的是内节点。所有用户记录都存储在B+树的叶子节点，所有目录项记录都存储在内节点。

2.InnoDB存储引擎会自动为主键（如果没有它会自动帮我们添加）建立聚簇索引，聚簇索引的叶子节点包含完整的用户记录。

3.我们可以为自己感兴趣的列建立二级索引，二级索引的叶子节点包含的用户记录由索引列 + 主键组成，所以如果想通过二级索引来查找完整的用户记录的话，需要通过回表操作，也就是在通过二级索引找到主键值之后再到聚簇索引中查找完整的用户记录。

4.B+树中每层节点都是按照索引列值从小到大的顺序排序而组成了双向链表，而且每个页内的记录（不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单链表。如果是联合索引的话，则页面和记录先按照联合索引前边的列排序，如果该列值相同，再按照联合索引后边的列排序。

5.通过索引查找记录是从B+树的根节点开始，一层一层向下搜索。由于每个页面都按照索引列的值建立了Page Directory（页目录），所以在这些页面中的查找非常快。

30. 查询名字以'As'开头的记录，那就可以这么写查询语句：
SELECT * FROM person_info WHERE name LIKE 'As%';

31. 查找索引列的值在某个范围内的记录
SELECT * FROM person_info WHERE name > 'Asa' AND name < 'Barlow';

32. B+树索引用于排序
ORDER BY name, birthday LIMIT 10
这种情况直接从索引的最左边开始往右读10行记录就可以了。

ORDER BY name DESC, birthday DESC LIMIT 10，
这种情况直接从索引的最右边开始往左读10行记录就可以了。

(叶子节点每条即每行记录，从左到右是递增的）

33. B+树索引如何使用好
1.需要回表的记录越多，使用二级索引的性能就越低

2.最好在查询列表里只包含索引列，比如这样：
SELECT name, birthday, phone_number FROM person_info WHERE name > 'Asa' AND name < 'Barlow'
我们很不鼓励用*号作为查询列表，最好把我们需要查询的列依次标明。

3.列的基数指的是某一列中不重复数据的个数，在记录行数一定的情况下，列的基数越大，该列中的值越分散，列的基数越小，该列中的值越集中。
最好为那些列的基数大的列建立索引，为基数太小列的建立索引效果可能不好。

4.我们这里所说的类型大小指的就是该类型表示的数据范围的大小。能表示的整数范围当然也是依次递增，如果我们想要对某个整数列建立索引的话，在表示的整数范围允许的情况下，尽量让索引列使用较小的类型.

5.CREATE TABLE person_info(
name VARCHAR(100) NOT NULL,
birthday DATE NOT NULL,
phone_number CHAR(11) NOT NULL,
country varchar(100) NOT NULL,
KEY idx_name_birthday_phone_number (name(10), birthday, phone_number)
);
name(10)就表示在建立的B+树索引中只保留记录的前10个字符的编码，这种只索引字符串值的前缀的策略是我们非常鼓励的，尤其是在字符串类型能存储的字符比较多的时候。

6.如果索引列在比较表达式中不是以单独列的形式出现，而是以某个表达式，或者函数调用形式出现的话，是用不到索引的。

7.让主键具有AUTO_INCREMENT，让存储引擎自己为表生成主键，而不是我们手动插入

34. 系统表空间 和 独立表空间
如果我们想把已经存在系统表空间中的表转移到独立表空间，可以使用下边的语法：

ALTER TABLE 表名 TABLESPACE [=] innodb_file_per_table;
或者把已经存在独立表空间的表转移到系统表空间，可以使用下边的语法：

ALTER TABLE 表名 TABLESPACE [=] innodb_system;
其中中括号扩起来的=可有可无

35. 编码值
键盘各键对应的编码值（key code）

36. InnoDB的表空间
我们的聚簇索引（也就是完整的表数据）和其他的二级索引都是以B+树的形式保存到表空间的，而B+树的节点就是数据页。

37. 随机io，顺序io
记录在磁盘中的存储是相连的，集中分布在一个或几个数据页中，我们可以很快的把这些连着的记录从磁盘中读出来，这种读取方式我们也可以称为顺序I/O。
录可能分布在不同的数据页中，这样读取完整的用户记录可能要访问更多的数据页，这种读取方式我们也可以称为随机I/O。
访问二级索引使用顺序I/O，访问聚簇索引使用随机I/O。

38. 段(segment)
设计InnoDB的大叔们提出了一个碎片（fragment）区的概念，也就是在一个碎片区中，并不是所有的页都是为了存储同一个段的数据而存在的，而是碎片区中的页可以用于不同的目的，比如有些页用于段A，有些页用于段B，有些页甚至哪个段都不属于。碎片区直属于表空间，并不属于任何一个段。所以此后为某个段分配存储空间的策略是这样的：

在刚开始向表中插入数据的时候，段是从某个碎片区以单个页面为单位来分配存储空间的。

当某个段已经占用了32个碎片区页面之后，就会以完整的区为单位来分配存储空间。

所以段不能仅定义为是某些区的集合，更精确的应该是某些零散的页面以及一些完整的区的集合。

每一个段对应一个INODE Entry结构，这个INODE Entry结构描述了这个段的各种信息

39. 区的分类
空闲的区：现在还没有用到这个区中的任何页面。

有剩余空间的碎片区：表示碎片区中还有可用的页面。

没有剩余空间的碎片区：表示碎片区中的所有页面都被使用，没有空闲页面。

附属于某个段的区。每一个索引都可以分为叶子节点段和非叶子节点段，除此之外InnoDB还会另外定义一些特殊作用的段，在这些段中的数据量很大时将使用区来作为基本的分配单位。

40.
当某个段已经占用了32个碎片区页面之后，就会以完整的区为单位来分配存储空间. ?

41.每个段中的区对应的XDES Entry结构可以分成FREE、NOT_FULL和FULL这3个链表
设计InnoDB的大叔们为每个段中的区对应的XDES Entry结构建立了三个链表：

FREE链表：同一个段中，所有页面都是空闲的区对应的XDES Entry结构会被加入到这个链表。注意和直属于表空间的FREE链表区别开了，此处的FREE链表是附属于某个段的。

NOT_FULL链表：同一个段中，仍有空闲空间的区对应的XDES Entry结构会被加入到这个链表。

FULL链表：同一个段中，已经没有空闲空间的区对应的XDES Entry结构会被加入到这个链表。

再次强调一遍，每一个索引都对应两个段，每个段都会维护上述的3个链表

42. 表空间链表小结
表空间是由若干个区组成的，每个区都对应一个XDES Entry的结构，直属于表空间的区对应的XDES Entry结构可以分成FREE、FREE_FRAG和FULL_FRAG这3个链表；每个段可以附属若干个区，每个段中的区对应的XDES Entry结构可以分成FREE、NOT_FULL和FULL这3个链表。个链表都对应一个List Base Node的结构，这个结构里记录了链表的头、尾节点的位置以及该链表中包含的节点数。正是因为这些链表的存在，管理这些区才变成了一件so easy的事情。

43. 组
对于16KB的页来说，连续的64个页就是一个区，也就是说一个区默认占用1MB空间大小。不论是系统表空间还是独立表空间，都可以看成是由若干个区组成的，每256个区被划分成一组。

44. 区
一个区就是在物理位置上连续的64个页

45. 顺序I/O
我们介绍B+树适用场景的时候特别提到范围查询只需要定位到最左边的记录和最右边的记录，然后沿着双向链表一直扫描就可以了，而如果链表中相邻的两个页物理位置离得非常远，就是所谓的随机I/O。再一次强调，磁盘的速度和内存的速度差了好几个数量级，随机I/O是非常慢的，所以我们应该尽量让链表中相邻的页的物理位置也相邻，这样进行范围查询的时候才可以使用所谓的顺序I/O。

所以，所以，所以才引入了区（extent）的概念，一个区就是在物理位置上连续的64个页。在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区为单位分配，甚至在表中的数据十分非常特别多的时候，可以一次性分配多个连续的区。虽然可能造成一点点空间的浪费（数据不足填充满整个区），但是从性能角度看，可以消除很多的随机I/O，功大于过嘛！

46.Segment Header结构
解决某个应哪个INODE Entry结构的问题

47.
什么是等值比较？
SELECT * FROM single_table WHERE key_part1 = 'god like' AND key_part2 > 'legendary';
等号是等值比较，非等号就不是等值比较了。

48.唯一二级索引
唯一二级索引的每一个索引对应值是唯一的， 而普通二级索引并不限制索引列值的唯一性。

49. 等值匹配才可以使用索引合并
之所以在二级索引列都是等值匹配的情况下才可能使用Intersection索引合并，是因为只有在这种情况下根据二级索引查询出的结果集是按照主键值排序的。

50. 实用建议
我们建议在真实工作中最好不要使用*作为查询列表，最好把真实用到的列作为查询列表。

51.索引列没有和常数比较，所以不能使用到索引
key3 > key2，这个搜索条件的索引列由于没有和常数比较，所以并不能使用到索引。
因为常数是固定的，才好去用索引来比较和查找

52. 目录项记录和数据也的关系
每一条目录项记录都对应一个数据页

53. 两表连接查询方式只内外连接的本质区别
外连接和内连接的本质区别就是：对于外连接的驱动表的记录来说，如果无法在被驱动表中找到匹配ON子句中的过滤条件的记录，那么该记录仍然会被加入到结果集中，对应的被驱动表记录的各个字段使用NULL值填充；而内连接的驱动表的记录如果无法在被驱动表中找到匹配ON子句中的过滤条件的记录，那么该记录会被舍弃。

54. union
UNION子句是干嘛用的，它会把多个查询的结果集合并起来并对结果集中的记录进行去重

55. 数据库在文件系统中的表示
CREATE DATABASE 数据库名，此语句创建一个数据库。
而每个数据库都对应数据目录下的一个子目录，或者说对应一个文件夹

56. 为什么子查询能被转化为连接查询 ?
查询优化器可能对涉及子查询的查询语句进行重写，从而转换为连接查询

57. 物化
设计MySQL的大叔把这个将子查询结果集中的记录保存到临时表的过程称之为物化（英文名：Materialize）

58. semi_join
MySQL的大叔在这里提出了一个新概念 --- 半连接（英文名：semi-join）。将s1表和s2表进行半连接的意思就是：对于s1表的某条记录来说，我们只关心在s2表中是否存在与之匹配的记录是否存在，而不关心具体有多少条记录与之匹配，最终的结果集中只保留s1表的记录。

59. 相关子查询可能被执行多次
内部查询的执行依赖于外部查询的数据，外部查询每执行一次，内部查询也会执行一次。每一次都是外部查询先执行，取出外部查询表中的一个元组，将当前元组中的数据传递给内部查询，然后执行内部查询。根据内部查询执行的结果，判断当前元组是否满足外部查询中的where条件，若满足则当前元组是符合要求的记录，否则不符合要求。然后，外部查询继续取出下一个元组数据，执行上述的操作，直到全部元组均被处理完毕。

60. explain
执行计划的一条记录就代表着MySQL对某个表的执行查询时的访问方法

列名	描述
id	在一个大的查询语句中每个SELECT关键字都对应一个唯一的id

61. 表的访问方法
const
通过主键或者唯一二级索引列来定位一条记录的

ref
当通过普通的二级索引列与常量进行等值匹配时来查询某个表，那么对该表的访问方法就可能是ref

system
当表中只有一条记录并且该表使用的存储引擎的统计数据是精确的，比如MyISAM、Memory，那么对该表的访问方法就是system

eq_ref
在连接查询时，如果被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问的（如果该主键或者唯一二级索引是联合索引的话，所有的索引列都必须进行等值比较），则对该被驱动表的访问方法就是eq_ref

ref_or_null
当对普通二级索引进行等值匹配查询，该索引列的值也可以是NULL值时，那么对该表的访问方法就可能是ref_or_null

index_merge
表示要用Intersection、Union、Sort-Union这三种索引合并的方式之一来执行查询
{
Intersection合并
Intersection翻译过来的意思是交集。这里是说某个查询可以使用多个二级索引，将从多个二级索引中查询到的结果取交集，比方说下边这个查询：
SELECT * FROM single_table WHERE key1 = 'a' AND key3 = 'b';
假设这个查询使用Intersection合并的方式执行的话，那这个过程就是这样的：
从idx_key1二级索引对应的B+树中取出key1 = 'a'的相关记录。
从idx_key3二级索引对应的B+树中取出key3 = 'b'的相关记录。
二级索引的记录都是由索引列 + 主键构成的，所以我们可以计算出这两个结果集中id值的交集。
按照上一步生成的id值列表进行回表操作，也就是从聚簇索引中把指定id值的完整用户记录取出来，返回给用户。

Union合并
Intersection是交集的意思，这适用于使用不同索引的搜索条件之间使用AND连接起来的情况；Union是并集的意思，适用于使用不同索引的搜索条件之间使用OR连接起来的情况。

Sort_Union
我们把这种先按照二级索引记录的主键值进行排序，之后按照Union索引合并方式执行的方式称之为Sort-Union索引合并，很显然，这种Sort-Union索引合并比单纯的Union索引合并多了一步对二级索引记录的主键值排序的过程。
}

unique_subquery
类似于两表连接中被驱动表的eq_ref访问方法，unique_subquery是针对在一些包含IN子查询的查询语句中，如果查询优化器决定将IN子查询转换为EXISTS子查询，而且子查询可以使用到主键进行等值匹配的话，那么该子查询执行计划的type列的值就是unique_subquery

index_subquery
index_subquery与unique_subquery类似，只不过访问子查询中的表时使用的是普通的索引

range
利用索引进行范围匹配的访问方法
如果使用索引获取某些范围区间的记录，那么就可能使用到range访问方法

index
当我们可以使用索引覆盖，但需要扫描全部的索引记录时，该表的访问方法就是index
(不需要回表，只需要用到索引的查询方式称为索引覆盖)

all
全表扫描

62. 扇出
我们把对驱动表进行查询后得到的记录条数称之为驱动表的扇出（英文名：fanout）。

63.嵌套循坏连接
这种驱动表只访问一次，但被驱动表却可能被多次访问，访问次数取决于对驱动表执行单表查询后的结果集中的记录条数的连接执行方式称之为嵌套循环连接（Nested-Loop Join）

64. 左右外连接
左外连接和右外连接的驱动表和被驱动表不能轻易互换

65. 连接查询
condition filtering
如果使用的是全表扫描的方式执行的单表查询，那么计算驱动表扇出时需要猜满足搜索条件的记录到底有多少条。
如果使用的是索引执行的单表扫描，那么计算驱动表扇出的时候需要猜满足除使用到对应索引的搜索条件外的其他搜索条件的记录有多少条。
设计MySQL的大叔把这个猜的过程称之为condition filtering。

设计MySQL的大叔引入了这个condition filtering的功能，就是还要猜一猜剩余的那些搜索条件能把驱动表中的记录再过滤多少条

66. 触发器
简单的说，就是一张表发生了某件事（插入、删除、更新操作），然后自动触发了预先编写好的若干条SQL语句的执行

67. 事务
我们现在知道事务是一个抽象的概念，它其实对应着一个或多个数据库操作

68. redo日志
redo日志会把事务在执行过程中对数据库所做的所有修改都记录下来，在之后系统奔溃重启后可以把事务所做的任何修改都恢复出来。

redo日志是顺序写入磁盘的
在执行事务的过程中，每执行一条语句，就可能产生若干条redo日志，这些日志是按照产生的顺序写入磁盘的，也就是使用顺序IO。

你扫描redo日志准备恢复页面的时候，日志对应修改过得页面是在磁盘里的。如果这个页面的FIL_PAGE_LSN代表的lsn值肯定大于checkpoint_lsn的值，
说明在发生崩溃前对这个页面的修改已经被刷新到了磁盘里。

69. undo日志
本质上就是一个指向记录对应的undo日志的一个指针

70. MVCC
对于使用InnoDB存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列:
trx_id: 每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的事务id赋值给trx_id隐藏列。
roll_pointer：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。

71.
