1. find
Run find to find file in dir:  $ find dir -name file -print 

The find command accepts special pattern-matching characters such as *, but you must enclose them in single quotes ('*')to protect the special characters from the shell's own globbing feature. 

2.file 
distinguish file's type

3. xargs
make the same command work on each arg passed to it individually, i.e. how many 'arg' passed by then how many 'command' would be execute

Many people use xargs with the find command. For example, the script below can help you verify that every file in the current directory tree that ends with .gif is actually a GIF (Graphic Interchange Format) image: 
$ find . -name '*.gif' -print | xargs file

In the example above, xargs runs the file command. However, this invocation can cause errors or leave your system open to security problems, because filenames can include spaces and newlines. When writing a script, use the following form instead, which changes the find output separator and the xargs argument delimiter from a newline to a NULL character: 
$ find . -name '*.gif' -print0 | xargs -0 file

xargs starts a lot of processes, so don’t expect great performance if you have a large list of files.  

You may need to add two dashes (--) to the end of your xargs command if there is a chance that any of the target files start with a single dash (-). The double dash (--) can be used to tell a program that any arguments that follow the double dash are filenames, not options. However, keep in mind that not all programs support the use of a double dash. 

There’s an alternative to xargs when using find: the -exec option. However, the syntax is somewhat tricky because you need to supply a {} to substitute the filename and a literal ; to indicate the end of the command. Here’s how to perform the preceding task using only find: 
$ find . -name '*.gif' -exec file {} \; 

4. pgrep
pgrep looks through  the  currently  running  processes and lists  the process IDs which match the selection criteria to stdout.  All the criteria have to match.
$ pgrep svr02

5. kill
When you run kill, you’re asking the kernel to send a signal to another process.
if kill not specify which signal to be sent, then would send TERM signal by default.
-s signal
send specify signal to process, the signal could be represented by number or signal name. signal 9 equal to SIGKILL, force to kill process.
$ kill -s 9 pid

6. free
$ free -m
show RAM's usage in Unit of MByte.

关于Buffers和Cached的区别，来自 http://www.taobaotesting.com/blogs/qa?bid=2265 的一段解释如下：

buffers是指用来给块设备做的缓冲大小，他只记录文件系统的metadata以及 tracking in-flight pages.

cached是用来给文件做缓冲。

那就是说：buffers是用来存储，目录里面有什么内容，权限等等。而cached直接用来记忆我们打开的文件

7. du
$ du -m filename
show disk space occupied by file in unit of MByte.

8. ps
To see every process on the system using standard syntax:
$ ps -ef

To see every process on the system using BSD syntax:
$ ps axu

查看进程：
1) ps 命令用于查看当前正在运行的进程。
grep 是搜索
例如： ps -ef | grep java
表示查看所有进程里 CMD 是 java 的进程信息
2) ps -aux | grep java
-aux 显示所有状态
ps
3) kill 命令用于终止进程
例如： kill -9 [PID]
-9 表示强迫进程立即停止
通常用 ps 查看进程 PID ，用 kill 命令终止进程

9. strings
显示文件中的可打印字符
$ strings /usr/lib64/libstdc++.so.6 | grep 'CXXABI'

10. ln
在文件之间建立连接
$ ln -s libstdc++.so.6.0.19 libstdc++.so.6
above command create a soft link.

11. linux 添加开机启动项
将写好的脚本（.sh文件）放到目录 /etc/profile.d/ 下，系统启动后就会自动执行该目录下的所有shell脚本。

12. pgrep
looks through the currently running processes and lists the process IDs which match the selection criteia to stdout.
$ pgrep processName | xargs kill -s 9 //this command used to kill the process represented by processName

13.
grep
print lines matching a pattern

-n, --line-number
Prefix each line of output with the 1-based (which means, the line number count from 1) line number within its input file.

-E, --extended-regexp
Interpret PATTERN as an extended regular expression, or use egrep command has the same effect with grep -E , coz grep only support basic RE by default

-q, --quiet, --silent
suppress all normal output, do not write anything to standard output

-l, --files-with-matches
Suppress normal output; instead print the name of each input file form which output would normally have been printed (which mean, print the matched filename only, which contained the matched contents). Then scanning will stop on the first match.

-Z, --null
Output a zero byte (the AXCII NUL character) instead of the character that normally follows a file name. For example, grep -lz outputs a zero byte after each file name instead of the usual newline. This option makes the output unambiguous, even in the presence o file names containing unusual characters like newlines. This iption can be used with commands like find -print0, perl -0, sort -z, and xargs -0 to process arbitrary file names, even those that contain newline characters.

-i, --ignore-case
Ignore case distinctions in both the PATTERN and the input files (which mean, a letter in upper-case or lower-case are the same).

-w, --word-regexp
Select only those lines containing matches that form whole words (which means, exactly match the search string in the entir fully-single form). The test is that the matching substring must either be at the beginning of the line, or preceded by a non-word constituent character. Similarly, it must be either at the end of the line or followed by a no-word constituent character. Word-constituent characters are letters, digits and the underscore.
i.e.
grep -w 'is' ./*
it would not print the line contain "this", "his".. but would display the line containing the fully-single word "is"

-R, -r, --recursive
recursive call, searches files in the current working directory and all subdirectories below it.

EXAMPLES
`find / -type f -print0 | xargs -0 grep -liwZ GUI | xargs -0 rm -f`
`grep -rliwZ GUI / | xargs -0 rm -f`
Either of the above will remove any file containing "GUI".

-v, --invert-atch
Invert the sense of matching, to select non-matching lines.
e.g.
grep pattern1 *.txt | grep -v pattern2
# Matches all lines in "*.txt" files containing "pattern1",
# but ***not*** "pattern2".

-c, --count
Suppress normal output; instead print a count of matching lines for each input file. With the -v, --invert-match option, would count non-matching lines.

-z, --null-data
Treat the input as a set of lines, each terminated by a zero byte (the ASCII NUL character) instead of a newline. Like the -Z or --null option, this option can be used with commands like sort -z to process arbitrary file names.

--color[=WHEN], --colour[=WHEN]
 Surround the matched (non-empty) strings, matching lines, context lines, file names, line numbers, byte offsets, and separators (for fields and groups of context lines) with escape sequences to display them in color on the terminal. The colors are defined by the environment variable GREP_COLORS. The deprecated environment variable GREP_COLOR is still supported, but its setting does not have priority. WHEN is never, always, or auto.

 The --color (or --colour) option marks the matching string in color (on the console or in an
 xterm window). Since grep prints out each entire line containing the matching pattern, this lets you
 see exactly what is being matched.

-H, --with-filename
Print the file name for each match. This is the default when there is more than one file to search.

-A NUM, --after-context=NUM
Print NUM lines of trailing context after matching lines (including the matched line). Places a line containing a group separator (--) between contiguous groups of matches. With the -o or --only-matching option, this has no effect and a warning is given

-o, --only-matching
Print only the matched (non-empty) parts of a matching line, with each such part on a separate output line.

-F, --basic-regexp
Interpret PATTERN as a list of ixed strings (instead of regular expressions), separated by newlines, any of which is to be matched.
fgrep -- fast grep -- is the same as grep -F. It does a literal string search (no Regular Expressions), which generally speeds things up a bit

-m NUM, --max-count=NUM
Stop reading a file after NUM matching lines.
